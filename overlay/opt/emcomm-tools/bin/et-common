#!/bin/bash
# Author  : Gaston Gonzalez
# Date    : 1 February 2025
# Updated : 7 June 2025
# Purpose : Common environment variables and functions

# Standardized device paths for supported hardware
export ET_DEVICE_AUDIO="/dev/et-audio"
export ET_DEVICE_CAT="/dev/et-cat"
export ET_DEVICE_GPS="/dev/et-gps"
export ET_DEVICE_SDR="/dev/et-sdr"

export ESC="\x1B"
export RED="${ESC}[1;31m"
export BLUE="${ESC}[1;34m"
export GREEN="${ESC}[1;32m"
export WHITE="${ESC}[97m"
export YELLOW="${ESC}[1;33m"
export NC="${ESC}[0m"

# Display an error message in the terminal
show-err-dialog() {
  local message="$1"
  dialog --title "Notification" --msgbox "$message" 8 60
}

# Display a notification message as a UI popup in the desktop
notify-user() {
  notify-send -t 5000 --app-name="EmComm Tools" "$1"
}

exit_if_no_sdr() {
  if [[ ! -e ${ET_DEVICE_SDR} ]]; then
    et-log "No ${ET_DEVICE_SDR} detected."
    exit 1
  fi
}

exit_on_service_failure() {
  local systemd_unit_name="$1"
  systemctl is-active --user --quiet "${systemd_unit_name}"
  if [ $? -ne 0 ]; then
    et-log "Can't start mode. ${systemd_unit_name} failed to start."
    exit 1
  fi
}

start_and_wait_for_service() {
  local timeout=15  # Total time to wait in seconds
  local interval=2  # Interval between checks in seconds
  local systemd_unit_name="$1"
  local elapsed=0

  et-log "Starting ${systemd_unit_name}..."
  systemctl --user start ${systemd_unit_name}

  et-log "Waiting for ${systemd_unit_name} to become active..."

  while ! systemctl is-active --user --quiet "${systemd_unit_name}"; do
      sleep "$interval"
      elapsed=$((elapsed + interval))
      if [ "$elapsed" -ge "$timeout" ]; then
          et-log "Timeout reached. ${systemd_unit_name} failed to start."
          exit 1
      fi
      et-log "Waiting for ${systemd_unit_name} to become active..."
  done

  # Some applications even when started still need a bit of extra time to be available.
  # Add a short think time of 2 seconds. The ARDOP modem requies extra time.
  sleep 2

  # Do one more check to ensure that we are running, otherwise exit.
  exit_on_service_failure ${systemd_unit_name}
}

